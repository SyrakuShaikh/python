# Time-stamp: <2016-03-27 Sun 17:36:02 Shaikh>
#+TITLE: Notes, More Like Sands.
#+AUTHOR: Shaikh
#+DATE: [2016-03-12 Sat]

* Object-Oriented Programming
** class, attribute, field, variable, object, instance...
From [[http://python.swaroopch.com/][A Byte of Python]] chapter 13.

A /class/ creates a new /type/. An /object/ is the /instance/ of a
/class/.

A /class/ has two *attributes* which are *field* and *method*.
Variables that belong to /object/ or /class/ are referred as *instance
variables* or *class variables* respectively, they consist of *field*.
*Method* is the functions belong to the /class/.

The difference between a /class/ and a /function/ is that the former
does have an intrinsic argument `self` in every method which need no
value when you call it.

Usually, there always be a `__init__` method in the definition of a
/class/ and as named, for initialization.

All /class/ members (including the data members) are *public* and all
the methods are *virtual* in Python with one exception: with names
using /double underscore/.
** inheritance
| type       | subtype       |
|------------+---------------|
| baseclass  | derived class |
| superclass | subclass      |

Python does not automatically call the constructor of the base class,
you have to explicitly call it yourself.
* Exceptions
** with statement
See [[https://www.python.org/dev/peps/pep-0343/][PEP 343]] for details. It is a simple and elegant way to replace the
`try...except...finally` statement in some situations.

Usually, it's like:
#+BEGIN_SRC python
  with EXPR as VAR:
      BLOCK
#+END_SRC

and is translated to:
#+BEGIN_SRC python
  mgr = (EXPR)
  exit = type(mgr).__exit__       # Not calling it ye
  value = type(mgr).__enter__(mgr)
  exc = True
  try:
      try:
          VAR = value             # Only if "as VAR" is present
          BLOCK
      except:
          # The exceptional case is handled here
          exc = False
          if not exit(mgr, *sys.exc_info()):
              raise
          # The exception is swallowed if exit() returns
          # true
  finally:
      # The normal and non-local-goto cases are handled here
      if exec:
          exit(mgr, None, None, None)
#+END_SRC
* Functions
The name of a function is, actually, the reference to an object of that
function. Therefore it is completely O.K. to assign the name to a variable like
an 'alias'.
* Misc
** Unary +
equals to operator.__pos__(). One of its affect as far as I know is to
get the value with its original precision.
